---
import Base from "../layouts/Base.astro";
import Experience from "../components/Experience.astro";
import Skills from "../components/Skills.astro";
import Projects from "../components/Projects.astro";
import Start from "../components/Start.astro";
import Wakatime from "../components/Wakatime.astro";
import Contact from "../components/Contact.astro";
import Education from "../components/Education.astro";
import ScrollToTop from "../components/ScrollToTop.astro";
import TopActionsContainer from "../components/TopActionsContainer.astro";
---

<Base>
    <main
        class="h-screen overflow-y-scroll snap-y snap-mandatory scroll-smooth bg-black text-white"
        id="scroll-root"
    >
        <TopActionsContainer />
        <Start />
        <Projects />
        <Skills />
        <Experience />
        <Education />
        <Wakatime />
        <Contact />
        <ScrollToTop />
    </main>

    <style is:global>
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        h1 {
            text-wrap: balance;
        }
    </style>

    <script>
        import { languages, getLang } from "../i18n";
        function updateTexts(lang, animate = false) {
            const t = languages[lang];
            const elements = document.querySelectorAll("[data-i18n]");

            elements.forEach((el) => {
                const key = el.dataset.i18n;
                const newText = t[key] ?? key;

                // Si no hay animación (primera carga), solo asignamos el texto
                if (!animate) {
                    el.textContent = newText;
                    return;
                }

                // --- Lógica de Animación (Solo al cambiar idioma) ---
                const isLevelBadge = el.classList.contains(
                    "group-hover:opacity-100",
                );

                if (!el.dataset.originalOpacity) {
                    el.dataset.originalOpacity =
                        window.getComputedStyle(el).opacity;
                }

                el.style.transition = "opacity 0.2s ease, transform 0.2s ease";
                el.style.opacity = "0";
                el.style.transform = "translateY(5px)";

                setTimeout(() => {
                    el.textContent = "";

                    if (isLevelBadge) {
                        el.style.opacity = "";
                    } else {
                        el.style.opacity = el.dataset.originalOpacity;
                    }

                    el.style.transform = "translateY(0)";

                    let i = 0;
                    const speed = 25;
                    function type() {
                        if (i < newText.length) {
                            el.textContent += newText.charAt(i);
                            i++;
                            setTimeout(type, speed);
                        }
                    }
                    type();
                }, 250);
            });
        }

        // 1. Ejecución inicial: SIN animación
        const currentLang = getLang();
        updateTexts(currentLang, false);

        // 2. Cambio manual: CON animación
        window.addEventListener("language-change", (e: any) => {
            updateTexts(e.detail.lang, true);
        });

        // --- 2. Animaciones de Aparición General (Intro/Skills/Exp) ---
        // (Tu código del IntersectionObserver se mantiene igual...)
        const observer = new IntersectionObserver(
            (entries) => {
                entries.forEach((entry) => {
                    if (entry.isIntersecting) {
                        entry.target.classList.remove(
                            "opacity-0",
                            "translate-y-10",
                            "translate-y-12",
                        );
                    }
                });
            },
            { threshold: 0.3 },
        );
        document
            .querySelectorAll("[data-animate]")
            .forEach((el) => observer.observe(el));

        // --- 3. Parallax y Navegación ---
        // (Tu código de Parallax y URL Observer se mantiene igual...)
        const root = document.getElementById("scroll-root");
        const parallaxItems = document.querySelectorAll("[data-parallax]");
        if (root) {
            root.addEventListener("scroll", () => {
                const scrollTop = root.scrollTop;
                parallaxItems.forEach((el: any) => {
                    const speed = Number(el.dataset.speed) || 0.2;
                    el.style.transform = `translateY(${scrollTop * speed}px)`;
                });
            });
        }

        // 1. Manejar el scroll automático al cargar
        window.addEventListener("load", () => {
            const hash = window.location.hash;
            if (hash) {
                const targetSection = document.querySelector(hash);
                if (targetSection)
                    targetSection.scrollIntoView({ behavior: "smooth" });
            }
        });

        // 2. Observer para actualizar la URL
        const urlObserver = new IntersectionObserver(
            (entries) => {
                entries.forEach((entry) => {
                    if (entry.isIntersecting && entry.target.id) {
                        history.replaceState(null, "", `#${entry.target.id}`);
                    }
                });
            },
            { threshold: 0.6 },
        );

        document
            .querySelectorAll("section[id]")
            .forEach((section) => urlObserver.observe(section));

        // Scroll instantáneo al hash inicial
        if (window.location.hash) {
            document
                .querySelector('section[id="' + window.location.hash + '"]')
                ?.scrollIntoView({ behavior: "instant" });
        }
    </script>
</Base>
